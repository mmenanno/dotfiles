#!/usr/bin/env zsh
# shellcheck disable=SC1071

# dv - Superpowered Development Workflow Script
# Smart navigation between development directories with collision handling.

if [[ "${ZSH_EVAL_CONTEXT:-}" == *:file ]]; then
    typeset -g DV_RUNTIME_MODE="function"
else
    emulate -L zsh
    setopt err_exit pipe_fail nounset extended_glob
    typeset -g DV_RUNTIME_MODE="script"
fi

0=${(%):-%N}
SCRIPT_DIR=${0:A:h}

if ! typeset -f log_error >/dev/null 2>&1; then
    source "$SCRIPT_DIR/shared"
fi

typeset -gA SPECIAL_DIRS=(
    dotfiles "$HOME/dotfiles"
    dev "$HOME/dev"
    writing "$HOME/writing"
)

typeset -ga PROJECT_PATHS=(
    "$HOME/dev"
    "$HOME/dev/git"
    "$HOME/writing"
)

typeset -gA PROJECT_MAP=()

show_help() {
    cat <<'EOT'
dv - Superpowered Development Workflow Script

USAGE:
    dv <command> [options]

COMMANDS:
    cd <target>       Navigate to a project or special directory
                      Special targets: dotfiles, dev, writing
                      Or any project name from indexed directories

    up [--force]      Install/update dependencies in current project
                      - Ruby projects: runs bundle install
                      - Rails projects: also runs pending migrations
                      - Node projects: runs npm/yarn/pnpm install
                      Use --force to reinstall even if up-to-date

    list, ls          List all available projects
    help, h           Show this help message

    <any-command>     Passthrough to project bin/ or toys commands
                      Priority: bin/<command> â†’ toys <command>

EXAMPLES:
    dv cd dotfiles          # Go to dotfiles
    dv cd dev               # Go to ~/dev root
    dv cd calendar_hub      # Go to calendar_hub project
    dv ls                   # List all available projects
    dv up                   # Install dependencies in current project
    dv checks               # Run bin/checks or toys checks
    dv rails console        # Run bin/rails console

NOTES:
    - Projects are auto-discovered from ~/dev, ~/dev/git, ~/writing
    - If multiple projects share a name, you'll be prompted to choose
    - Use with zsh completion for best experience (tab to complete project names)
    - When sourced in your shell, 'dv cd' changes directory directly
    - Project commands (up, passthrough) work in current directory
EOT
}

index_projects() {
    typeset -gA PROJECT_MAP=()
    local search_path project_dir project_name

    for search_path in "${PROJECT_PATHS[@]}"; do
        [[ -d $search_path ]] || continue
        setopt localoptions null_glob
        for project_dir in "$search_path"/*(/N); do
            project_name="${project_dir:t}"
            if [[ -n ${PROJECT_MAP[$project_name]:-} ]]; then
                PROJECT_MAP[$project_name]+=",$project_dir"
            else
                PROJECT_MAP[$project_name]="$project_dir"
            fi
        done
    done
}

resolve_collision() {
    local project_name="$1"
    local paths_csv="$2"
    local selection
    local -a paths

    IFS=',' read -rA paths <<< "$paths_csv"
    if (( ${#paths[@]} == 0 )); then
        log_error "No matching paths found for $project_name"
        return 1
    fi

    if command -v fzf >/dev/null 2>&1 && [[ -t 0 ]]; then
        selection=$(printf '%s\n' "${paths[@]}" | fzf --prompt="Select ${project_name}> " --ansi --no-multi)
        if [[ -z $selection ]]; then
            log_error "Selection cancelled"
            return 1
        fi
        printf '%s\n' "$selection"
        return 0
    fi

    log_warning "Multiple projects found for '$project_name':"
    echo "" >&2

    local index=1 path
    for path in "${paths[@]}"; do
        printf '  %d) %s\n' "$index" "$path" >&2
        ((index++))
    done

    echo "" >&2
    printf 'Select project (1-%d): ' "${#paths[@]}" >&2
    if ! read -r selection; then
        log_error "Selection cancelled"
        return 1
    fi

    if [[ $selection != <-> ]] || (( selection < 1 || selection > ${#paths[@]} )); then
        log_error "Invalid selection: $selection"
        return 1
    fi

    printf '%s\n' "${paths[$selection]}"
}

# Project detection helpers
is_ruby_project() {
    [[ -f Gemfile ]]
}

is_rails_project() {
    [[ -f config/application.rb ]] || [[ -f bin/rails ]]
}

is_node_project() {
    [[ -f package.json ]]
}

has_toys() {
    [[ -f .toys.rb ]] || [[ -d .toys ]]
}

has_pending_migrations() {
    if ! is_rails_project; then
        return 1
    fi

    local rails_cmd=""
    if [[ -x bin/rails ]]; then
        rails_cmd="bin/rails"
    elif command -v bundle >/dev/null 2>&1; then
        rails_cmd="bundle exec rails"
    else
        return 1
    fi

    local status_output
    if status_output=$($rails_cmd db:migrate:status 2>&1); then
        echo "$status_output" | grep -q "^\s*down"
    else
        # If we can't check status, assume no pending migrations
        return 1
    fi
}

find_project_command() {
    local command_name="$1"

    # Priority 1: Project bin/ directory
    if [[ -x "bin/$command_name" ]]; then
        printf 'bin/%s' "$command_name"
        return 0
    fi

    # Priority 2: Toys
    if has_toys && command -v toys >/dev/null 2>&1; then
        # Check .toys directory for command files first (more reliable)
        if [[ -d .toys && -f ".toys/${command_name}.rb" ]]; then
            printf 'toys %s' "$command_name"
            return 0
        fi

        # Fall back to checking toys --commands (may fail if toys config has errors)
        if toys --commands 2>/dev/null | grep -q "^${command_name}\$"; then
            printf 'toys %s' "$command_name"
            return 0
        fi
    fi

    return 1
}

cmd_cd() {
    local target="${1:-}"
    local target_path

    if [[ -z $target ]]; then
        log_error "No target specified"
        log_info "Usage: dv cd <target>"
        return 1
    fi

    if [[ -n ${SPECIAL_DIRS[$target]:-} ]]; then
        target_path="${SPECIAL_DIRS[$target]}"
    else
        index_projects
        if [[ -z ${PROJECT_MAP[$target]:-} ]]; then
            log_error "Project not found: $target"
            log_info "Run 'dv ls' to see available projects"
            return 1
        fi
        target_path="${PROJECT_MAP[$target]}"
        if [[ $target_path == *,* ]]; then
            if ! target_path="$(resolve_collision "$target" "$target_path")"; then
                return 1
            fi
        fi
    fi

    if [[ ${DV_RUNTIME_MODE} == "function" ]]; then
        builtin cd -- "$target_path" || return 1
    else
        printf '%s\n' "$target_path"
    fi
}

cmd_up() {
    local force=false
    local did_something=false

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --force|-f)
                force=true
                ;;
            *)
                log_error "Unknown option: $arg"
                log_info "Usage: dv up [--force]"
                return 1
                ;;
        esac
    done

    # Ruby/Rails project handling
    if is_ruby_project; then
        if ! command -v bundle >/dev/null 2>&1; then
            log_warning "Bundler not found, skipping bundle install"
        else
            log_info "Running bundle install..."
            if [[ $force == true ]]; then
                bundle install --redownload
            else
                bundle install
            fi
            if [[ $? -eq 0 ]]; then
                log_success "Bundle install completed"
                did_something=true
            else
                log_error "Bundle install failed"
                return 1
            fi

            # Check for pending migrations
            if is_rails_project; then
                if has_pending_migrations; then
                    log_info "Running pending migrations..."
                    local rails_cmd=""
                    if [[ -x bin/rails ]]; then
                        rails_cmd="bin/rails"
                    else
                        rails_cmd="bundle exec rails"
                    fi

                    $rails_cmd db:migrate
                    if [[ $? -eq 0 ]]; then
                        log_success "Migrations completed"
                    else
                        log_error "Migrations failed"
                        return 1
                    fi
                else
                    log_info "No pending migrations"
                fi
            fi
        fi
    fi

    # Node.js project handling
    if is_node_project; then
        local pkg_manager=""

        # Detect package manager
        if [[ -f pnpm-lock.yaml ]] && command -v pnpm >/dev/null 2>&1; then
            pkg_manager="pnpm"
        elif [[ -f yarn.lock ]] && command -v yarn >/dev/null 2>&1; then
            pkg_manager="yarn"
        elif command -v npm >/dev/null 2>&1; then
            pkg_manager="npm"
        else
            log_warning "No Node.js package manager found, skipping install"
        fi

        if [[ -n $pkg_manager ]]; then
            log_info "Running $pkg_manager install..."
            if [[ $force == true ]]; then
                # Force reinstall by removing node_modules first
                if [[ -d node_modules ]]; then
                    log_info "Removing node_modules for clean install..."
                    rm -rf node_modules
                fi
            fi

            $pkg_manager install
            if [[ $? -eq 0 ]]; then
                log_success "$pkg_manager install completed"
                did_something=true
            else
                log_error "$pkg_manager install failed"
                return 1
            fi
        fi
    fi

    if [[ $did_something == false ]]; then
        log_warning "No recognized project type in current directory"
        log_info "Supported: Ruby (Gemfile), Node.js (package.json)"
        return 1
    fi

    log_success "All dependencies up to date!"
}

cmd_list() {
    local filter_dev=false
    local filter_writing=false

    local invalid_arg=""
    for arg in "$@"; do
        case "$arg" in
            -d|--dev)
                filter_dev=true
                ;;
            -w|--writing)
                filter_writing=true
                ;;
            *)
                invalid_arg="$arg"
                break
                ;;
        esac
    done

    if [[ -n $invalid_arg ]]; then
        log_error "Unknown option: $invalid_arg"
        echo ""
        show_help
        return 1
    fi

    should_include_path() {
        local path="$1"
        if [[ $filter_dev == false && $filter_writing == false ]]; then
            return 0
        fi

        local include=false
        if [[ $filter_dev == true ]]; then
            if [[ $path == */dev || $path == */dev/* ]]; then
                include=true
            fi
        fi

        if [[ $filter_writing == true ]]; then
            if [[ $path == */writing || $path == */writing/* ]]; then
                include=true
            fi
        fi

        [[ $include == true ]]
    }

    log_info "Special directories:"
    local -a special_names sorted_special
    special_names=("${(@k)SPECIAL_DIRS}")
    sorted_special=("${(@o)special_names}")
    local name
    local printed_special=false
    for name in "${sorted_special[@]}"; do
        local special_path="${SPECIAL_DIRS[$name]}"
        if should_include_path "$special_path"; then
            printf '  %-20s -> %s\n' "$name" "$special_path"
            printed_special=true
        fi
    done
    if [[ $printed_special == false ]]; then
        echo "  (no special directories match filters)"
    fi

    echo ""
    log_info "Indexed projects:"

    index_projects
    local -a project_names sorted_projects
    project_names=("${(@k)PROJECT_MAP}")
    if (( ${#project_names[@]} == 0 )); then
        echo "  (no projects found)"
    else
        sorted_projects=("${(@o)project_names}")
        local paths path
        local printed_project=false
        for name in "${sorted_projects[@]}"; do
            paths="${PROJECT_MAP[$name]}"
            if [[ $paths == *,* ]]; then
                local -a path_array filtered_paths
                IFS=',' read -rA path_array <<< "$paths"
                for path in "${path_array[@]}"; do
                    if should_include_path "$path"; then
                        filtered_paths+=("$path")
                    fi
                done

                if (( ${#filtered_paths[@]} == 0 )); then
                    continue
                fi

                if (( ${#filtered_paths[@]} == 1 )); then
                    printf '  %-20s -> %s\n' "$name" "${filtered_paths[1]}"
                else
                    printf '  %-20s -> %s\n' "$name" "[MULTIPLE]"
                    for path in "${filtered_paths[@]}"; do
                        printf '  %-20s    - %s\n' "" "$path"
                    done
                fi
            else
                if should_include_path "$paths"; then
                    printf '  %-20s -> %s\n' "$name" "$paths"
                else
                    continue
                fi
            fi
            printed_project=true
        done

        if [[ $printed_project == false ]]; then
            echo "  (no projects match filters)"
        fi
    fi

    unset -f should_include_path
}

cmd_passthrough() {
    local command_name="$1"
    shift

    local resolved_command
    if ! resolved_command="$(find_project_command "$command_name")"; then
        log_error "Command not found: $command_name"
        log_info "No bin/$command_name or toys $command_name available in current directory"
        return 1
    fi

    # Execute the resolved command with all remaining arguments
    # resolved_command may be "bin/foo" or "toys foo", so we need to split it properly
    log_info "Running: $resolved_command $*"
    eval "$resolved_command \"\$@\""
}

dv_main() {
    local command="${1:-help}"
    shift $(( $# ? 1 : 0 ))
    case "$command" in
        cd)
            cmd_cd "$@"
            ;;
        up)
            cmd_up "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        help|h|--help|-h)
            show_help
            ;;
        *)
            # Try passthrough to bin/ or toys
            cmd_passthrough "$command" "$@"
            ;;
    esac
}

if [[ ${DV_RUNTIME_MODE} == "function" ]]; then
    dv() {
        dv_main "$@"
    }
else
    dv_main "$@"
fi
