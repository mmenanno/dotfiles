#!/bin/bash
# gclean - Clean up merged git branches and prune remote references
# Usage: gclean [options]

set -euo pipefail

# shellcheck disable=SC1091
source "${BASH_SOURCE[0]%/*}/shared"

# Default configuration
DRY_RUN=false
FORCE=false
KEEP_CURRENT=true

# Print usage information
show_help() {
    cat << EOF
gclean - Clean up merged git branches and prune remote references

USAGE:
    gclean [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -d, --dry-run           Show what would be deleted without actually doing it
    -f, --force             Force delete branches (use -D instead of -d)
    --keep-current          Keep current branch even if it would be deleted (default)
    --no-keep-current       Allow deletion of current branch

DESCRIPTION:
    This script performs the following cleanup operations:
    1. Switch to the default branch (main or master)
    2. Pull latest changes from remote
    3. Prune remote branch references
    4. Delete merged local branches (except protected ones)

EXAMPLES:
    gclean                         # Standard cleanup
    gclean -d                      # Preview what would be deleted
    gclean --force                 # Force delete unmerged branches

EOF
}

# Get the default branch name (main or master)
get_default_branch() {
    local default_branch

    # Try to get from remote
    default_branch=$(git remote show origin 2>/dev/null | grep "HEAD branch" | cut -d' ' -f5 2>/dev/null || echo "")

    # Fall back to checking what exists locally
    if [[ -z "$default_branch" ]]; then
        if git show-ref --verify --quiet refs/heads/main; then
            default_branch="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            default_branch="master"
        else
            log_error "Could not determine default branch (neither 'main' nor 'master' found)"
            exit 1
        fi
    fi

    echo "$default_branch"
}

# Get current branch name
get_current_branch() {
    git branch --show-current
}

# Get list of branches to delete
get_branches_to_delete() {
    local default_branch="$1"
    local current_branch="$2"
    local -a branches_to_delete=()

    # Get merged branches (excluding default branch)
    while IFS= read -r branch; do
        # Skip empty lines
        [[ -z "$branch" ]] && continue

        # Skip default branch
        [[ "$branch" == "$default_branch" ]] && continue

        # Skip current branch if KEEP_CURRENT is true
        if [[ "$KEEP_CURRENT" == true && "$branch" == "$current_branch" ]]; then
            continue
        fi

        branches_to_delete+=("$branch")
    done < <(git branch --merged "$default_branch" --format='%(refname:short)' | grep -v "^$default_branch$")

    # Print each branch on a new line (handle empty array safely)
    if [[ ${#branches_to_delete[@]} -gt 0 ]]; then
        printf '%s\n' "${branches_to_delete[@]}"
    fi
}

# Perform git operations
perform_cleanup() {
    local default_branch current_branch

    default_branch=$(get_default_branch)
    current_branch=$(get_current_branch)

    log_info "Default branch: $default_branch"
    log_info "Current branch: $current_branch"

    # Switch to default branch if not already there
    if [[ "$current_branch" != "$default_branch" ]]; then
        log_info "Switching to $default_branch branch..."
        if [[ "$DRY_RUN" == false ]]; then
            git checkout "$default_branch"
        fi
    fi

    # Pull latest changes
    log_info "Pulling latest changes..."
    if [[ "$DRY_RUN" == false ]]; then
        git pull --prune
    fi

    # Prune remote references
    log_info "Pruning remote branch references..."
    if [[ "$DRY_RUN" == false ]]; then
        git remote prune origin
    fi

    # Get branches to delete
    local branches_to_delete_str
    branches_to_delete_str=$(get_branches_to_delete "$default_branch" "$current_branch")

    if [[ -z "$branches_to_delete_str" ]]; then
        log_info "No merged branches found to delete"
        return 0
    fi

    # Convert to array
    local -a branches_to_delete
    while IFS= read -r line; do
        [[ -n "$line" ]] && branches_to_delete+=("$line")
    done <<< "$branches_to_delete_str"

    # Show what will be deleted
    log_info "Found ${#branches_to_delete[@]} branches to be deleted:"
    for branch in "${branches_to_delete[@]}"; do
        echo "  - $branch"
    done

    if [[ "$DRY_RUN" == true ]]; then
        log_warning "DRY RUN: No branches were actually deleted"
        return 0
    fi

    # Delete branches
    log_info "Deleting merged branches..."
    local delete_flag="-d"
    if [[ "$FORCE" == true ]]; then
        delete_flag="-D"
        log_warning "Using force delete (-D)"
    fi

    local deleted_count=0
    local failed_count=0

    for branch in "${branches_to_delete[@]}"; do
        if git branch "$delete_flag" "$branch" 2>/dev/null; then
            log_success "Deleted branch: $branch"
            ((deleted_count++))
        else
            log_error "Failed to delete branch: $branch"
            ((failed_count++))
        fi
    done

    # Summary
    log_success "Cleanup complete: $deleted_count deleted, $failed_count failed"

    if [[ $failed_count -gt 0 ]]; then
        log_warning "Some branches could not be deleted. Use --force to force delete unmerged branches."
        return 1
    fi

    return 0
}

# Parse command line arguments
parse_args() {
    while (( $# > 0 )); do
        case "$1" in
            -h|--help)
                show_help_and_exit
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            --keep-current)
                KEEP_CURRENT=true
                shift
                ;;
            --no-keep-current)
                KEEP_CURRENT=false
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                log_error "Use -h or --help for usage information"
                exit 1
                ;;
            *)
                log_error "Unexpected argument: $1"
                log_error "Use -h or --help for usage information"
                exit 1
                ;;
        esac
    done
}

# Main function
main() {
    # Parse arguments
    parse_args "$@"

    # Check if we're in a git repo
    check_git_repo

    # Show configuration
    if [[ "$DRY_RUN" == true ]]; then
        log_info "DRY RUN MODE - No changes will be made"
    fi

    log_info "Starting git repository cleanup..."

    # Perform cleanup
    if perform_cleanup; then
        log_success "Git repository cleanup completed successfully!"
    else
        log_error "Git repository cleanup completed with some failures"
        exit 1
    fi
}

# Run main function with all arguments
main "$@"
