#!/bin/bash

# webm2mp4 - Convert WebM files to MP4 format
# Usage: webm2mp4 [options] [file_or_directory]

set -euo pipefail

# shellcheck disable=SC1091
source "${BASH_SOURCE[0]%/*}/shared"

# Default configuration
DEFAULT_CRF=23
DEFAULT_AUDIO_BITRATE="128k"
DEFAULT_THREADS=4
VERBOSE=false
QUIET=false
OVERWRITE=false
OUTPUT_DIR=""
CRF=$DEFAULT_CRF
AUDIO_BITRATE=$DEFAULT_AUDIO_BITRATE
PARALLEL_JOBS=1

# Print usage information
show_help() {
    cat << EOF
webm2mp4 - Convert WebM files to MP4 format

USAGE:
    webm2mp4 [OPTIONS] [FILE_OR_DIRECTORY]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -q, --quiet             Suppress all output except errors
    -f, --force             Overwrite existing output files
    -o, --output DIR        Output directory (default: same as input)
    -c, --crf VALUE         Video quality (0-51, lower=better, default: $DEFAULT_CRF)
    -a, --audio-bitrate BR  Audio bitrate (default: $DEFAULT_AUDIO_BITRATE)
    -j, --jobs COUNT        Number of parallel jobs (default: 1)

EXAMPLES:
    webm2mp4                           # Convert all .webm files in current directory
    webm2mp4 video.webm                # Convert single file
    webm2mp4 /path/to/videos           # Convert all .webm files in directory
    webm2mp4 -c 18 -a 192k video.webm  # Higher quality conversion
    webm2mp4 -j 4 /videos              # Process 4 files in parallel
    webm2mp4 -o /output /input         # Convert to different output directory

EOF
}

# Check if required tools are available
check_dependencies() {
    check_command "ffmpeg" "Please install ffmpeg: brew install ffmpeg (macOS) or apt install ffmpeg (Ubuntu)"

    log_verbose "ffmpeg found: $(command -v ffmpeg)"
    log_verbose "ffmpeg version: $(ffmpeg -version 2>/dev/null | head -n1)"
}

# Convert a single WebM file to MP4
convert_file() {
    local input_file="$1"
    local output_file="$2"
    local file_num="$3"
    local total_files="$4"

    # Check if input file exists and is readable
    if [[ ! -f "$input_file" ]]; then
        log_error "Input file does not exist: $input_file"
        return 1
    fi

    if [[ ! -r "$input_file" ]]; then
        log_error "Cannot read input file: $input_file"
        return 1
    fi

    # Check if output file already exists
    if [[ -f "$output_file" && "$OVERWRITE" == false ]]; then
        log_warning "Output file already exists (use -f to overwrite): $output_file"
        return 1
    fi

    # Create output directory if it doesn't exist
    local output_dir
    output_dir="$(dirname "$output_file")"
    if [[ ! -d "$output_dir" ]]; then
        log_verbose "Creating output directory: $output_dir"
        if ! mkdir -p "$output_dir"; then
            log_error "Failed to create output directory: $output_dir"
            return 1
        fi
    fi

    log_info "[$file_num/$total_files] Converting: $(basename "$input_file")"
    log_verbose "Input:  $input_file"
    log_verbose "Output: $output_file"
    log_verbose "CRF: $CRF, Audio bitrate: $AUDIO_BITRATE"

    # Build ffmpeg command
    local ffmpeg_cmd=(
        ffmpeg
        -i "$input_file"
        -c:v libx264
        -crf "$CRF"
        -c:a aac
        -b:a "$AUDIO_BITRATE"
        -threads "$DEFAULT_THREADS"
    )

    if [[ "$OVERWRITE" == true ]]; then
        ffmpeg_cmd+=(-y)
    fi

    if [[ "$QUIET" == true ]]; then
        ffmpeg_cmd+=(-loglevel error)
    elif [[ "$VERBOSE" == false ]]; then
        ffmpeg_cmd+=(-loglevel warning)
    fi

    ffmpeg_cmd+=("$output_file")

    log_verbose "Running: ${ffmpeg_cmd[*]}"

    # Execute conversion
    local start_time
    start_time=$(date +%s)

    if "${ffmpeg_cmd[@]}"; then
        local end_time duration
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        log_success "Converted $(basename "$input_file") in ${duration}s"
        return 0
    else
        log_error "Failed to convert: $input_file"
        return 1
    fi
}

# Process files in parallel
process_files() {
    local -a files=("$@")
    local total_files=${#files[@]}
    local -a pids=()
    local -a results=()
    local success_count=0
    local failed_count=0

    if (( total_files == 0 )); then
        log_warning "No WebM files found to convert"
        return 0
    fi

    log_info "Found $total_files WebM file(s) to convert"
    log_info "Using $PARALLEL_JOBS parallel job(s)"

    # Process files
    for i in "${!files[@]}"; do
        local input_file="${files[i]}"
        local filename
        filename="$(basename "$input_file" .webm)"

        local output_file
        if [[ -n "$OUTPUT_DIR" ]]; then
            output_file="$OUTPUT_DIR/${filename}.mp4"
        else
            output_file="$(dirname "$input_file")/${filename}.mp4"
        fi

        # Wait if we've reached the parallel job limit
        if (( ${#pids[@]} >= PARALLEL_JOBS )); then
            wait "${pids[0]}"
            local exit_code=$?
            if (( exit_code == 0 )); then
                ((success_count++))
            else
                ((failed_count++))
            fi
            pids=("${pids[@]:1}")
        fi

        # Start conversion in background
        if (( PARALLEL_JOBS > 1 )); then
            convert_file "$input_file" "$output_file" "$((i+1))" "$total_files" &
            pids+=($!)
        else
            if convert_file "$input_file" "$output_file" "$((i+1))" "$total_files"; then
                ((success_count++))
            else
                ((failed_count++))
            fi
        fi
    done

    # Wait for remaining background jobs
    for pid in "${pids[@]}"; do
        wait "$pid"
        local exit_code=$?
        if (( exit_code == 0 )); then
            ((success_count++))
        else
            ((failed_count++))
        fi
    done

    # Print summary
    log_info "Conversion complete: $success_count successful, $failed_count failed"

    if (( failed_count > 0 )); then
        return 1
    fi

    return 0
}

# Find WebM files in a directory or handle single file
find_webm_files() {
    local target="$1"
    local -a files=()

    if [[ -f "$target" ]]; then
        # Single file
        if [[ "$target" == *.webm ]]; then
            files=("$target")
        else
            log_error "File is not a WebM file: $target"
            return 1
        fi
    elif [[ -d "$target" ]]; then
        # Directory - find all WebM files
        log_verbose "Searching for WebM files in: $target"
        while IFS= read -r -d '' file; do
            files+=("$file")
        done < <(find "$target" -maxdepth 1 -name "*.webm" -type f -print0 2>/dev/null)
    else
        log_error "Path does not exist: $target"
        return 1
    fi

    if (( ${#files[@]} == 0 )); then
        log_warning "No WebM files found in: $target"
        return 1
    fi

    # Sort files for consistent processing order
    IFS=$'\n' files=($(sort <<<"${files[*]}"))
    unset IFS

    process_files "${files[@]}"
}

# Parse command line arguments
parse_args() {
    while (( $# > 0 )); do
        case "$1" in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -f|--force)
                OVERWRITE=true
                shift
                ;;
            -o|--output)
                require_argument "$1" "${2:-}" || return 1
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -c|--crf)
                require_argument "$1" "${2:-}" || return 1
                CRF="$2"
                validate_numeric "$CRF" "CRF" 0 51
                shift 2
                ;;
            -a|--audio-bitrate)
                require_argument "$1" "${2:-}" || return 1
                AUDIO_BITRATE="$2"
                shift 2
                ;;
            -j|--jobs)
                require_argument "$1" "${2:-}" || return 1
                PARALLEL_JOBS="$2"
                validate_numeric "$PARALLEL_JOBS" "jobs" 1 16
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                log_error "Unknown option: $1"
                log_error "Use -h or --help for usage information"
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    # Validate conflicting options
    if [[ "$VERBOSE" == true && "$QUIET" == true ]]; then
        log_error "Cannot use both --verbose and --quiet options"
        return 1
    fi

    # Validate output directory
    if [[ -n "$OUTPUT_DIR" ]]; then
        if [[ -f "$OUTPUT_DIR" ]]; then
            log_error "Output path is a file, not a directory: $OUTPUT_DIR"
            return 1
        fi

        # Convert to absolute path
        OUTPUT_DIR="$(cd "$(dirname "$OUTPUT_DIR")" 2>/dev/null && pwd)/$(basename "$OUTPUT_DIR")" || {
            log_error "Invalid output directory: $OUTPUT_DIR"
            return 1
        }

        log_verbose "Output directory: $OUTPUT_DIR"
    fi

    # Determine target (file or directory)
    local target="${1:-.}"  # Default to current directory

    if [[ ! -e "$target" ]]; then
        log_error "Target does not exist: $target"
        return 1
    fi

    echo "$target"
}

# Main function
main() {
    log_verbose "webm2mp4 starting with arguments: $*"

    # Handle help option early
    for arg in "$@"; do
        if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
            show_help_and_exit
        fi
    done

    # Check dependencies first
    check_dependencies

    # Parse arguments
    local target
    set +e  # Temporarily disable exit on error
    target="$(parse_args "$@")"
    local parse_exit_code=$?
    set -e  # Re-enable exit on error

    if (( parse_exit_code != 0 )); then
        exit 1
    fi

    log_verbose "Target: $target"
    log_verbose "Configuration: CRF=$CRF, Audio=$AUDIO_BITRATE, Jobs=$PARALLEL_JOBS"

    # Find and process files
    if find_webm_files "$target"; then
        log_success "All conversions completed successfully"
        exit 0
    else
        log_error "Some conversions failed"
        exit 1
    fi
}

# Run main function with all arguments
main "$@"
