#!/usr/bin/env bash

# System Cleanup Script
# Runs various cleanup tasks and reports space freed

set -euo pipefail

# Get script directory and source shared utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=./shared
source "$SCRIPT_DIR/shared"

# Configuration
DOCKER_TIMEOUT=60  # seconds to wait for Docker to start
FORCE=false
DOCKER_STARTED_BY_US=false
SUDO_KEEPALIVE_PID=""
CLEANUP_STARTED=false

# Cleanup handler for interrupts and exit
cleanup_on_exit() {
    local exit_code=$?

    # Kill sudo keepalive process if running
    if [[ -n "$SUDO_KEEPALIVE_PID" ]]; then
        kill "$SUDO_KEEPALIVE_PID" 2>/dev/null || true
    fi

    # Stop Docker if we started it
    if [[ "$DOCKER_STARTED_BY_US" == true ]]; then
        if command -v docker &>/dev/null && docker info &>/dev/null; then
            echo ""
            log_info "Stopping Docker (was not running before cleanup)..."
            if ! osascript -e 'quit app "Docker"' 2>&1; then
                log_warning "Could not stop Docker automatically - you may need to stop it manually"
            fi
        fi
    fi

    # Show interrupted message if killed by signal during cleanup
    if [[ $exit_code -ne 0 ]] && [[ "$CLEANUP_STARTED" == true ]]; then
        echo ""
        log_warning "Cleanup interrupted"
    fi
}

# Set up trap for signals
trap cleanup_on_exit EXIT INT TERM

show_help() {
    cat << EOF
System Cleanup Script

Runs various cleanup tasks and reports total space freed.

USAGE:
    clean [options]

OPTIONS:
    -f, --force    Skip confirmation prompt
    -h, --help     Show this help message

CLEANUP TASKS:
    - Nix garbage collection and store optimization
    - Homebrew cleanup
    - Docker system prune (starts Docker if needed)
    - npm/pnpm/yarn cache cleanup
    - Ruby gem cleanup
    - Go module cache cleanup
    - macOS cache and log cleanup
    - Xcode derived data and archives

EXAMPLES:
    clean          # Run with confirmation prompt
    clean --force  # Run without confirmation

EOF
}

# Get used disk space in bytes for the root volume
get_disk_usage() {
    df -k / | tail -1 | awk '{print $3 * 1024}'
}

# Convert bytes to human-readable format
bytes_to_human() {
    local bytes=$1
    if (( bytes >= 1073741824 )); then
        printf "%.2f GB" "$(echo "scale=2; $bytes / 1073741824" | bc)"
    elif (( bytes >= 1048576 )); then
        printf "%.2f MB" "$(echo "scale=2; $bytes / 1048576" | bc)"
    elif (( bytes >= 1024 )); then
        printf "%.2f KB" "$(echo "scale=2; $bytes / 1024" | bc)"
    else
        printf "%d bytes" "$bytes"
    fi
}

# Wait for Docker to be ready
wait_for_docker() {
    local elapsed=0
    log_info "Waiting for Docker to start..."
    while ! docker info &>/dev/null; do
        if (( elapsed >= DOCKER_TIMEOUT )); then
            log_error "Docker failed to start within ${DOCKER_TIMEOUT} seconds"
            return 1
        fi
        sleep 2
        elapsed=$((elapsed + 2))
    done
    log_success "Docker is ready"
}

cleanup_nix() {
    log_info "Cleaning Nix store..."

    if ! command -v nix-collect-garbage &>/dev/null; then
        log_warning "Nix not installed, skipping"
        return 0
    fi

    log_info "Running garbage collection..."
    if ! sudo nix-collect-garbage -d 2>&1 | tail -5; then
        log_warning "Nix garbage collection had issues (continuing anyway)"
    fi

    log_info "Optimizing Nix store..."
    if ! nix store optimise 2>&1 | tail -3; then
        log_warning "Nix store optimization had issues (non-fatal)"
    fi

    log_success "Nix cleanup complete"
}

cleanup_homebrew() {
    log_info "Cleaning Homebrew..."

    if ! command -v brew &>/dev/null; then
        log_warning "Homebrew not installed, skipping"
        return 0
    fi

    if ! brew cleanup --prune=all 2>&1 | tail -5; then
        log_warning "Homebrew cleanup had issues (continuing anyway)"
    fi
    log_success "Homebrew cleanup complete"
}

cleanup_docker() {
    log_info "Cleaning Docker..."

    if ! command -v docker &>/dev/null; then
        log_warning "Docker not installed, skipping"
        return 0
    fi

    if docker info &>/dev/null; then
        true  # Docker already running, nothing to do
    else
        log_info "Starting Docker..."
        open -a Docker
        if ! wait_for_docker; then
            log_warning "Could not start Docker, skipping"
            return 0
        fi
        DOCKER_STARTED_BY_US=true
    fi

    if ! docker system prune -a --volumes -f 2>&1 | tail -5; then
        log_warning "Docker prune had issues (continuing anyway)"
    fi
    log_success "Docker cleanup complete"
}

cleanup_npm() {
    if command -v npm &>/dev/null; then
        log_info "Cleaning npm cache..."
        npm cache clean --force 2>&1 | grep -v "warn using --force" | tail -3 || true
        log_success "npm cache cleaned"
    fi
}

cleanup_pnpm() {
    if command -v pnpm &>/dev/null; then
        log_info "Cleaning pnpm store..."
        pnpm store prune 2>&1 | tail -3 || true
        log_success "pnpm store cleaned"
    fi
}

cleanup_yarn() {
    if command -v yarn &>/dev/null; then
        log_info "Cleaning yarn cache..."
        yarn cache clean 2>&1 | tail -3 || true
        log_success "yarn cache cleaned"
    fi
}

cleanup_ruby() {
    if command -v gem &>/dev/null; then
        log_info "Cleaning Ruby gems..."
        gem cleanup 2>&1 | tail -5 || true
        log_success "Ruby gems cleaned"
    fi
}

cleanup_go() {
    if command -v go &>/dev/null; then
        log_info "Cleaning Go module cache..."
        go clean -modcache 2>&1 || true
        log_success "Go module cache cleaned"
    fi
}

cleanup_macos_caches() {
    log_info "Cleaning macOS caches..."

    # User caches - some may be skipped if in use by running applications
    if [[ -d "$HOME/Library/Caches" ]]; then
        log_info "Cleaning user caches (some may be skipped if in use)..."
        local cache_errors
        if cache_errors=$(rm -rf "$HOME/Library/Caches/"* 2>&1); then
            log_success "User caches cleaned"
        else
            local error_count
            error_count=$(echo "$cache_errors" | grep -c "Permission denied\|Operation not permitted\|Device busy" || echo "0")
            if [[ "$error_count" -gt 0 ]]; then
                log_warning "User caches partially cleaned ($error_count items skipped - in use or protected)"
            else
                log_success "User caches cleaned"
            fi
        fi
    fi

    # User logs
    if [[ -d "$HOME/Library/Logs" ]]; then
        log_info "Cleaning user logs..."
        if rm -rf "$HOME/Library/Logs/"* 2>&1; then
            log_success "User logs cleaned"
        else
            log_warning "User logs partially cleaned (some items in use)"
        fi
    fi

    # System logs - only clean old/rotated logs to avoid breaking active logging
    log_info "Cleaning old system logs..."
    local cleaned=false
    if sudo find /var/log -type f \( -name "*.gz" -o -name "*.bz2" -o -name "*.old" -o -name "*.[0-9]" \) -delete 2>/dev/null; then
        cleaned=true
    fi
    if sudo find /var/log -type f -name "*.log" -mtime +7 -delete 2>/dev/null; then
        cleaned=true
    fi
    if [[ "$cleaned" == true ]]; then
        log_success "Old system logs cleaned"
    else
        log_warning "System logs: some items could not be cleaned (protected or in use)"
    fi
}

cleanup_xcode() {
    log_info "Cleaning Xcode..."

    local cleaned=false
    local partial=false

    if [[ -d "$HOME/Library/Developer/Xcode/DerivedData" ]]; then
        if rm -rf "$HOME/Library/Developer/Xcode/DerivedData" 2>&1; then
            cleaned=true
        else
            log_warning "DerivedData partially cleaned (Xcode may be running)"
            partial=true
        fi
    fi

    if [[ -d "$HOME/Library/Developer/Xcode/Archives" ]]; then
        if rm -rf "$HOME/Library/Developer/Xcode/Archives" 2>&1; then
            cleaned=true
        else
            log_warning "Archives partially cleaned (some files in use)"
            partial=true
        fi
    fi

    if [[ "$cleaned" == true ]] && [[ "$partial" == false ]]; then
        log_success "Xcode cleanup complete"
    elif [[ "$cleaned" == true ]] || [[ "$partial" == true ]]; then
        log_success "Xcode cleanup complete (some items skipped)"
    else
        log_info "No Xcode data to clean"
    fi
}

acquire_sudo() {
    log_info "Acquiring sudo credentials..."
    if ! sudo -v; then
        log_error "Failed to acquire sudo credentials"
        exit 1
    fi

    # Keep sudo alive in background (sudo credentials expire after ~5 mins by default)
    (
        while sudo -n true 2>/dev/null; do
            sleep 50
        done
    ) &
    SUDO_KEEPALIVE_PID=$!
}

run_cleanup() {
    local start_usage
    local end_usage
    local freed_bytes

    CLEANUP_STARTED=true

    echo ""
    acquire_sudo
    echo ""
    log_info "Starting system cleanup..."
    echo ""

    start_usage=$(get_disk_usage)

    cleanup_nix
    echo ""

    cleanup_homebrew
    echo ""

    cleanup_docker
    echo ""

    log_info "Cleaning package manager caches..."
    cleanup_npm
    cleanup_pnpm
    cleanup_yarn
    echo ""

    cleanup_ruby
    echo ""

    cleanup_go
    echo ""

    cleanup_macos_caches
    echo ""

    cleanup_xcode
    echo ""

    end_usage=$(get_disk_usage)
    freed_bytes=$((start_usage - end_usage))

    echo ""
    echo "========================================="
    if (( freed_bytes > 0 )); then
        log_success "Cleanup complete! Freed $(bytes_to_human "$freed_bytes")"
    elif (( freed_bytes < 0 )); then
        local gained=$(( 0 - freed_bytes ))
        log_success "Cleanup complete! (disk usage increased by $(bytes_to_human "$gained") due to concurrent activity)"
    else
        log_success "Cleanup complete! (disk usage unchanged)"
    fi
    echo "========================================="
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -f|--force)
            FORCE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

if [[ "$FORCE" == true ]]; then
    run_cleanup
else
    echo ""
    log_warning "This will run system cleanup tasks including:"
    echo "  - Nix garbage collection and store optimization (sudo required)"
    echo "  - Homebrew cleanup"
    echo "  - Docker prune (will start Docker if not running)"
    echo "  - Package manager cache cleanup (npm, pnpm, yarn)"
    echo "  - Ruby gem cleanup"
    echo "  - Go module cache cleanup"
    echo "  - macOS user caches/logs cleanup (some items may be skipped if in use)"
    echo "  - Old system logs cleanup (sudo required, only archived/old logs)"
    echo "  - Xcode derived data and archives cleanup"
    echo ""
    log_warning "Continue? (y/N) [60s timeout]"
    if read -r -t 60 response; then
        if [[ "$response" =~ ^[Yy]$ ]]; then
            run_cleanup
        else
            log_info "Cleanup cancelled"
        fi
    else
        echo ""
        log_info "Cleanup cancelled (timed out waiting for input)"
    fi
fi
